'''
from fastapi import FastAPI, UploadFile, File
import duckdb
from pathlib import Path
import requests
import csv
import io
import os
from datetime import datetime
from typing import List, Dict, Any
import json
from fastapi.responses import HTMLResponse

from typing import Optional
from fastapi.responses import RedirectResponse
from fastapi import Form 
from fastapi.responses import RedirectResponse
from db import init_db,get_db
from routes.dashboard import dashboard_router
from routes.transactions import transactions_router






app = FastAPI()
@app.on_event("startup")
def startup():
    init_db()

OLLAMA_BASE_URL = os.getenv("OLLAMA_BASE_URL")
# Database setup
DB_PATH = "/app/data/budget.db"

init_db()






# LEGACY: transitional in-memory buffer. 
#latest_transactions = []

@app.get("/health/ollama")
def ollama_health():
    r = requests.post(
        f"{OLLAMA_BASE_URL}/api/generate",
        json={
            "model": "qwen2.5:14b",
            "prompt": "Reply with the single word: OK",
            "stream": False
        },
        timeout=60
    )
    return r.json()








@app.post("/categorize/pending")
def categorize_pending(limit: int = 20):
    """
    Categorize uncategorized transactions.
    1) Apply deterministic category_rules
    2) Send remaining rows to Ollama
    """

    conn = get_db()

    # Fetch rules
    rules = conn.execute("""
        SELECT pattern, min_amount, max_amount, category
        FROM category_rules
        ORDER BY length(pattern) DESC, min_amount DESC
    """).fetchall()

    # Fetch uncategorized transactions
    rows = conn.execute("""
        SELECT id, date, description, amount
        FROM transactions
        WHERE category IS NULL
        ORDER BY date
        LIMIT ?
    """, [limit]).fetchall()

    if not rows:
        conn.close()
        return {"status": "nothing to categorize"}

    resolved_ids = set()
    remaining_rows = []

    # ----------------------------
    # 1) APPLY RULES FIRST
    # ----------------------------
    for txn_id, date, desc, amount in rows:
        matched = False

        for pattern, min_amt, max_amt, category in rules:
            if desc and pattern.lower() in desc.lower():
                if (min_amt is None or amount >= min_amt) and \
                   (max_amt is None or amount <= max_amt):

                    conn.execute("""
                        UPDATE transactions
                        SET category = ?
                        WHERE id = ?
                    """, [category, txn_id])

                    resolved_ids.add(txn_id)
                    matched = True
                    break

        if not matched:
            remaining_rows.append((txn_id, date, desc, amount))

    # If rules handled everything, skip LLM
    if not remaining_rows:
        conn.close()
        return {
            "requested": len(rows),
            "updated": len(resolved_ids),
            "via_rules": len(resolved_ids),
            "via_llm": 0
        }

    # ----------------------------
    # 2) BUILD LLM PROMPT
    # ----------------------------
    lines = [
        f"ID {r[0]} | {r[1]} | {r[2]} | ${r[3]:.2f}"
        for r in remaining_rows
    ]

    prompt = f"""
You are categorizing financial transactions.

Return ONLY valid JSON in this exact format:
[
  {{ "id": 123, "category": "Groceries" }}
]

Use short, common category names.
Do not include explanations.

Transactions:
{chr(10).join(lines)}
"""

    # ----------------------------
    # 3) CALL OLLAMA
    # ----------------------------
    resp = requests.post(
        f"{OLLAMA_BASE_URL}/api/generate",
        json={
            "model": "qwen2.5:14b",
            "prompt": prompt,
            "stream": False,
            "options": {
                "num_predict": 500
            }
        },
        timeout=300
    )

    if resp.status_code != 200:
        conn.close()
        return {"error": "Ollama request failed", "details": resp.text}

    try:
        data = json.loads(resp.json()["response"])
    except Exception:
        conn.close()
        return {
            "error": "Failed to parse LLM response",
            "raw_response": resp.json().get("response")
        }

    # ----------------------------
    # 4) UPDATE FROM LLM
    # ----------------------------
    llm_updated = 0

    for item in data:
        if "id" not in item or "category" not in item:
            continue

        conn.execute("""
            UPDATE transactions
            SET category = ?
            WHERE id = ?
        """, [item["category"], item["id"]])

        llm_updated += 1

    conn.close()

    return {
        "requested": len(rows),
        "updated": len(resolved_ids) + llm_updated,
        "via_rules": len(resolved_ids),
        "via_llm": llm_updated
    }











from fastapi.responses import HTMLResponse
from fastapi import Request
from fastapi.templating import Jinja2Templates
from datetime import date

templates = Jinja2Templates(directory="templates")

@app.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request):
    conn = get_db()

    # Current balance
    result = conn.execute("""
        SELECT COALESCE(SUM(amount), 0) FROM transactions
    """).fetchone()

    current_balance = result[0]

    

    
    )

'''
